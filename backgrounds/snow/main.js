(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by LiveScript 1.3.0
(function(){
  var glslify, mod;
  glslify = require('glslify');
  mod = {
    id: 'snow',
    name: "Snow",
    type: 'background',
    desc: "Snow fall in winter time",
    tags: ['freeze', 'cold', 'winter', 'christmas', 'ice', 'snow'],
    slug: "blue-snow-backgorund",
    license: 'CC0',
    edit: {
      bg1: {
        name: "Background 1",
        type: 'color',
        'default': '#1059a2'
      },
      bg2: {
        name: "Background 2",
        type: 'color',
        'default': '#ffe8e8'
      },
      fg: {
        name: "Foreground",
        type: 'color',
        'default': '#ffffff'
      },
      speed: {
        'default': 1
      },
      blur: {
        name: "Blur",
        type: 'number',
        'default': 0.09,
        min: 0.01,
        max: 0.09,
        step: 0.005
      },
      fade: {
        name: "Fade",
        type: 'number',
        'default': 0.2,
        min: -0.5,
        max: 0.5,
        step: 0.01
      },
      range: {
        name: "Range",
        type: 'number',
        'default': 3,
        min: 1,
        max: 4,
        step: 0.1
      }
    },
    support: {},
    watch: function(n, o){
      var u, i$, ref$, len$, name, results$ = [];
      u = this.shaders[0].uniforms;
      for (i$ = 0, len$ = (ref$ = ['fg', 'bg1', 'bg2']).length; i$ < len$; ++i$) {
        name = ref$[i$];
        u[name].value = ldColor.rgbfv(n[name]);
      }
      for (i$ = 0, len$ = (ref$ = ['speed', 'blur', 'fade', 'range']).length; i$ < len$; ++i$) {
        name = ref$[i$];
        results$.push(u[name].value = n[name]);
      }
      return results$;
    },
    shaders: [{
      uniforms: {
        bg1: {
          type: '3fv',
          value: [0.06, 0.35, 0.64]
        },
        bg2: {
          type: '3fv',
          value: [1, 0.91, 0.91]
        },
        fg: {
          type: '3fv',
          value: [1, 1, 1]
        },
        speed: {
          type: '1f',
          value: 2
        },
        blur: {
          type: '1f',
          value: 1
        },
        fade: {
          type: '1f',
          value: 0.2
        },
        range: {
          type: '1f',
          value: 3
        }
      },
      fragmentShader: glslify(["precision highp float;\n#define GLSLIFY 1\n/* z: pixel size */\nvec3 aspect_ratio_1540259130(vec2 res, int iscover) {\n  // iscover: 0 = contains, 1 = cover, 2 = stretch\n  float r;\n  vec3 ret = vec3((gl_FragCoord.xy / res.xy), 0.);\n  if(iscover == 2) {\n    ret.z = 1. / max(res.x, res.y);\n  } else if(iscover == 0 ^^ res.x > res.y) {\n    r = res.y / res.x;\n    ret.y = ret.y * r - (r - 1.) * 0.5;\n    ret.z = 1. / (iscover == 0 ? res.x : res.y);\n  } else {\n    r = res.x / res.y;\n    ret.x = (ret.x * r) - (r - 1.) * 0.5;\n    ret.z = 1. / (iscover == 0 ? res.y : res.x);\n  } \n  return ret;\n}\n\n/*\nret.y = ret.y * res.y / res.x\nret.x = ret.x * res.x / res.x\nret.xy = ret.xy * res.yx / max(res.x, res.y)\n\nfloat base;\nbase = res.xy / (iscover == 0 ? min(res.x, res.y) : max(res.x, res.y));\nret.z = 1. / base;\nret.xy = ( ret.xy * res.yx / base ) - ret.xy / base;\n*/\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n        float i = floor(x);\n        float f = fract(x);\n        float u = f * f * (3.0 - 2.0 * f);\n        return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n        vec2 i = floor(x);\n        vec2 f = fract(x);\n\n        // Four corners in 2D of a tile\n        float a = hash(i);\n        float b = hash(i + vec2(1.0, 0.0));\n        float c = hash(i + vec2(0.0, 1.0));\n        float d = hash(i + vec2(1.0, 1.0));\n\n        // Simple 2D lerp using smoothstep envelope between the values.\n        // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n        //                      mix(c, d, smoothstep(0.0, 1.0, f.x)),\n        //                      smoothstep(0.0, 1.0, f.y)));\n\n        // Same code, with the clamps in smoothstep and common subexpressions\n        // optimized away.\n        vec2 u = f * f * (3.0 - 2.0 * f);\n        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n        const vec3 step = vec3(110, 241, 171);\n\n        vec3 i = floor(x);\n        vec3 f = fract(x);\n \n        // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n        // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n        vec3 u = f * f * (3.0 - 2.0 * f);\n        return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(float x) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec2 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  // Rotate to reduce axial bias\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\nfloat fbm(vec3 x) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  for (int i = 0; i < NUM_OCTAVES; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n#define NUM_ITERATION 5.\n\nfloat raster_cloud_1062606552(vec2 uv, float t, vec2 dir, float delta) {\n  float c = 0.;\n  for(float i=1.;i<NUM_ITERATION;i++) {\n    c += fbm(vec2(uv.x * i + t * pow(delta,i) * 0.001 * dir.x, uv.y * i + t * pow(delta, i) * 0.001 * dir.y));\n  }\n  c = c / (NUM_ITERATION - 2.);\n  return c;\n}\n\nfloat vignette(float max, float amount, vec2 uv_0) {\n  return max - length(uv_0 - .5) * amount;\n}\n\nfloat blend_overlay_2281831123(float a, float b) {\n  return b < 0.5 ? 2. * a * b : 1. - (2. * (1. - a) * (1. - b));\n}\n\nvec3 blend_overlay_2281831123(vec3 a, vec3 b) {\n  return vec3(\n    blend_overlay_2281831123(a.r, b.r),\n    blend_overlay_2281831123(a.g, b.g),\n    blend_overlay_2281831123(a.b, b.b)\n  );\n}\n\nvec4 blend_overlay_2281831123(vec4 a, vec4 b) {\n  return vec4((blend_overlay_2281831123(vec3(a), vec3(b)) * b.a + vec3(a) * (1. - b.a)), a.a);\n}\n\nuniform float uTime, speed, blur, fade, range;\nuniform vec2 uResolution;\nuniform vec3 fg, bg1, bg2;\n\nvec2 getpt(vec2 id, float t, float layer) {\n  vec2 pt = vec2(noise(id.x + noise(id.y) * 625.788 + layer) * t, noise(id.y + noise(id.x) * 9527.145) * t);\n  pt = vec2(cos(pt.x), sin(pt.y)) * 0.2;\n  return pt;\n}\n\nvoid main() {\n  float t = (uTime * speed) + 1324.78, f, d;\n  float size = 20., s;\n  vec3 uv3 = aspect_ratio_1540259130(uResolution, 0);\n  vec2 uv, id, pt, duv;\n  f = 0.;\n  for(float i=0.;i<3.;i++) {\n    size = 9. - range * i;\n    duv = vec2(uv3) + t * 0.6 / size + i * 0.2;\n    uv = fract(vec2(duv) * size) - 0.5;\n    id = floor(vec2(duv) * size);\n    s = noise(id) * (0.1 + i * 0.025);\n    pt = getpt(id, t, i);\n    d = length(uv - pt);\n    if(fbm(id * 27.2266) < 0.5) { continue; }\n    f += (\n      clamp(smoothstep(0.02 + (0.02 + blur) * i + s, 0.02 * i + s, d), 0., 1.) *\n      pow(2., 2. - i) / 6.\n    );\n  }\n  float c = raster_cloud_1062606552(vec2(uv3), t * 10., vec2(1., 0.), 2.) * 0.9;\n  vec3 bg = mix(vec3(1.), mix(bg1, bg2, c), fade + uv3.y);\n  gl_FragColor = vec4(mix(bg, fg, f), 1.);\n}\n"])
    }],
    init: function(arg$){
      var shaderlib;
      shaderlib = arg$.shaderlib;
      return import$(this, shaderlib.prepare(this.shaders));
    },
    step: function(t){
      return this.renderer.render(t);
    },
    destroy: function(){}
  };
  if (typeof module != 'undefined' && module !== null) {
    module.exports = mod;
  }
  if (typeof ModManager != 'undefined' && ModManager !== null) {
    ModManager.register(mod);
  }
  return mod;
})();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
},{"glslify":2}],2:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}]},{},[1]);
